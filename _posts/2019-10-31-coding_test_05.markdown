---
layout: post
title: 코딩테스트 파이썬으로 풀기5
date: 2019-10-31 00:00:00 +0300
description: # Add post description (optional)
tags: [코딩문제풀이, python] # add tag
categories: [코딩문제풀이] # add categories
---

# 파이썬 입문겸 문제풀기
# [2020카카오공채] 문자열 압축
문제 참고 : https://programmers.co.kr/learn/courses/30/lessons/60057?language=python

* * *
# 문제풀이
짜투리시간마다 풀었던 문제...진정 돌대가리 굴리기 힘들었다. 파이썬 문자열, 배열 처리하는 부분에도 많이 애먹었고..<br>
원하는대로 조립할 수 없었다..아니 못했다.. 그래서 비교할 문자열을 리스트로 만들어서 순차 비교하였고,<br>
리스트를 겨우 만들었는데 그 후에는 더 시간이 걸렸다..<br>
어려운 문제일 수록 쉽게 생각해야한다는 점 오래만에 다시 깨닳았다. 돌대가리도 꾸준하게 돌려줘야겠다..<br>

일단 생각해낸 방식은 cnt_tmp 변수로 카운트 증가시켜주기.. 그전에는 이것도 문자열 인덱싱으로 해보려다 파이썬은 string 의 3번째자리수를 바꿔버린다던지 이렇게는 되지않았다.<br>

그 다음 시도는 2차원배열에 key(개수) => value(문자열) 와 같이 처리해보려했으나 파이썬 역시 가독성을 중시하여서 그런지 예제가 잘..... 찾다가 파이썬 성격에 맞지않는다 생각하여 간단하게 할 수 없을까 생각하다 cnt_tmp 가 생각났다. 앞으로는 이런 방식이 가장먼저 떠오르길...어렵게 생각하는 방식은 왜이렇게 꾸준한걸까

느낀 점은 아주 조금이지만 파이썬으로 코딩을 하다보면.. 또는 다른 예제들을 살펴보면 파이썬의 소스는 가독성을 중요시하는것이 눈에 많이 띄고, 좀 더 쉽게 짜려고 다른 생소한 함수들을 찾아나서지 않게된다. 좋은걸까

아래 코드는 정답이긴하나 모법답안을 좀 찾아보았는데 내소스 길이의 1/2 이다..허허
내가 처음에 시도하려했던 문자열 처리로 해결한 소스이다. 잘 알아둬야겠다.
```
def solution(s):

    answer = 1000
    if len(s) == 1:
        return 1
    for i in range(1, len(s)/2+1):

        # 최종 압축 문자열
        string = '';

        # 비교할 리스트 미리 만들기
        list_arr = []
        for j in range(0, len(s), i):
            list_arr.append(s[j:j+i])

        # 문자 압축
        cnt_tmp = 1
        for k in range(0, len(list_arr)):

            #  마지막 리스트 값일때
            if k == len(list_arr) -1:
                if cnt_tmp == 1:
                    cnt_tmp = "";
                string += str(cnt_tmp) + list_arr[k];
                break

            if list_arr[k] == list_arr[k+1]:
                cnt_tmp += 1
            else:
                if cnt_tmp > 1:
                    string += str(cnt_tmp) + list_arr[k];
                else:
                    string += list_arr[k];

                cnt_tmp = 1

        if len(string) < answer:
            answer = len(string)

    return answer
```

```
def solution(s):
    min_value=99999
    answer = 0
    if len(s)==1:
        return 1
    for size in range(1,int(len(s)/2)+1): # 문자열 비교 블럭 크기(1/2이 최대압축)
        count=0
        before_word="" # 첫글자 넣기.
        for i in range(0,len(s)+1,size): # 사이즈별 비교
            if before_word[-size:]==s[i:i+size]: # 같다면
                count+=1
            else: # 다르다면
                if count > 1:
                    before_word +=str(count)+s[i:i+size]
                else:
                    before_word +=s[i:i+size]
                count=1
        if min_value > len(before_word):
            min_value=len(before_word)
    return min_value
```