---
layout: post
title: "Data Fusion"
subtitle: "What is the data fusion and how does it work"
date: 2022-02-10
background: '/img/posts/kalman-filter/1.PNG'
---


<p>
    For example, we have a car move in one direction where it moves forward and backwards. 
    So the state \(x\) is the position of the car, and the kinematics represent by the dynamic 
    of the car where the kinematic compute the state of the car. 
    Due to the noize in the sensor, we don't know exactly the car's position. 
    Therefore, the start position is not known exactly where we have a distribution probability of the position, 
    as shown in the figure below. Now, when the car starts moving, the probability will start to grow and evolve through the time 
    . Therefore, the uncertainty is growing. The initial probability of the start position growing due to the
    effect of the noisy kinematics of the car. 
</p>
<p>
    Now we have information from the GPS that tells the car's position with a sure accuracy. 
    (e.g. +/- 10m). This sensor provides as we a measured probability distribution. We can put both measurements into an updated probability distribution that gives us more accurate positions using this information. 
    Using these updated methods to measure the position through time, the probability distribution will get smaller 
    and smaller. 
</p>

<p>
    The process occurs at the top consisting of two steps which are (1) prediction step and (2) update step. 
    In the first step, the dynamic of the car updates the current state \(x_t\) where the uncertainty grows while 
    the second step updates the current state \(x_t\) and reduces the uncertainty in the system. 
</p>
<p>
    The fusion process can be done by Bayes' Theorem using different probability distributions or we can use the Kalman filter.
</p>
<p>
    The Kalman filter considers a robust mathematical model used in data fusion where it simplifies the problem. 
    The Kalman filter solve linear systems \( \hat x = f(x | z_1, .... z_n )\), where \(\hat x\) is the estimated state, \(x\) 
    is the uncertain state and \(z_1 , z_n \) is the noisy measured state. So the Kalman filter minimise the state using 
    the noizy measurment to get as close as possible to the accurate state \(\hat x = min J\). Therefore, the problem convert 
    to minimizing the error between the noizy state and the estimated state \(\overline x = x - \hat x \) , 
    where  \(\overline x \) is the state estimation error. We have the state estimation Covariance \(P = [(x- \hat x)(x- \hat x)^T]\) 
    and the cost function Jacobian \( J= [(x- \hat x)^T(x- \hat x)] = Tr(P) \). 
    Therefore, we can minimise the cost function \(J\).
</p>

<p>
    There are differently typed Kalman filters (KF) due to the computation efficiency. 
    However, due to the Kalman filter process, only linear equations and Extended Kalman filter 
    (EKF) was designed to work on a non-linear model by approximating the model to linearize the 
    relationship and use a linear Covariance. 
    Therefore, EKF works with models that can linearize.
    Since some models cannot approximate a linear model, an Unscented Kalman Filter (UKF) 
    developed to work with non-linear models to calculate the prediction and updated equations. 
    The UKF linearize the uncertainty Covariance instead of linearizing the models' dynamics.
</p>

<h2 class="subsection-heading">An implementation of KF in arduino</h2>

<p>
    Now I am going to implement KF in Arduino to provide me with a more accurate data reading of 
    IMU sensor (MUP-6050). We will correct one roll angle of the sensor.
</p>
<p>
    The class below is the Kalman filter algorithms for a singel input state. 
    The class define multiple virables which define in the function to compute the kalman gain. 
    The update function is used to compute the updated kalman gain and the corrected state.
</p>


{% highlight ruby %}
class Kalamn_filter
{
  public:
    const float R = 20;   // noise coverance
    const float H = 1.00;  // measure map scalar
    float Q = 2;           // initial estimation covariance
    float P = 0;           //error covariance
    float x_hat = 0;       // updated state
    float K = 0; //kalman gain;
  float Update(int x)
    {
    
    K = P*H/(H*P*H+R); // update kalman gain
    x_hat = x_hat + K*(x-H*x_hat);

    // update error covariance 
    P= (1-K*H)*P+Q;

    return x_hat;
    }
};
};
{% endhighlight %}

<p>
    The blow code is the setup and main function loop where we define the Serial and we initialize the sensor 
    and the kalman filter class. In the main loop we get the data from the snesor and pass it to the update function 
    to calculate the estimated state.
</p>

{% highlight ruby %}
Kalamn_filter kalman_filter();
void setup() {
    // put your setup code here, to run once:
      Serial.begin(9600);
  
    Serial.println("Initialize MPU6050");
  
    while(!mpu.begin(MPU6050_SCALE_2000DPS, MPU6050_RANGE_2G))
    {
      Serial.println("Could not find a valid MPU6050 sensor, check wiring!");
      delay(500);
    }
  
    // Initilize Kalman filter 
  }
  
  void loop() {
    // put your main code here, to run repeatedly:
    // Read normalized values 
    Vector normAccel = mpu.readNormalizeAccel();
  
    // Calculate Roll
    int roll = (atan2(normAccel.YAxis, normAccel.ZAxis)*180.0)/M_PI;
  
    float roll_correct = kalman_filter(roll);
    // Output
    Serial.print(" Roll = ");
    Serial.print(roll);
    Serial.print(" Roll_correct = ");
    Serial.print(roll_correct);
    
    Serial.println();
    
    delay(10);
  }
{% endhighlight %}

<p>
    The figure below shows the raw data and the output of the Kalman filter. 
    As can be seen that the estimated roll has a smooth curve.
</p>



<p>
    The complete code is below
</p>



{% highlight ruby %}
#include <Wire.h>
    #include <MPU6050.h> 
    
    MPU6050 mpu;
    
    class Kalamn_filter
    {
      public:
        const float R = 20;   // noise coverance
        const float H = 1.00;  // measure map scalar
        float Q = 2;           // initial estimation covariance
        float P = 0;           //error covariance
        float x_hat = 0;       // updated state
        float K = 0; //kalman gain;
      float Update(int x)
        {
        
        K = P*H/(H*P*H+R); // update kalman gain
        x_hat = x_hat + K*(x-H*x_hat);
    
        // update error covariance 
        P= (1-K*H)*P+Q;
    
        return x_hat;
        }
    };
    
    // Initilize Kalman filter 
    Kalamn_filter kalman_filter;
    
    void setup() {
      // put your setup code here, to run once:
        Serial.begin(9600);
    
      Serial.println("Initialize MPU6050");
    
      while(!mpu.begin(MPU6050_SCALE_2000DPS, MPU6050_RANGE_2G))
      {
        Serial.println("Could not find a valid MPU6050 sensor, check wiring!");
        delay(500);
      }
    
    }
    
    void loop() {
      // put your main code here, to run repeatedly:
      // Read normalized values 
      Vector normAccel = mpu.readNormalizeAccel();
    
      // Calculate Roll
      int roll = (atan2(normAccel.YAxis, normAccel.ZAxis)*180.0)/M_PI;
    
      float roll_correct = kalman_filter.Update(roll);
      // Output
      Serial.print(" Roll = ");
      Serial.print(roll);
      Serial.print(" Roll_correct = ");
      Serial.print(roll_correct);
      Serial.println();
      
      delay(10);
    }
{% endhighlight %}